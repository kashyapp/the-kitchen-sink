<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<BASE HREF="http://www.cabochon.com/~stevey/blog-rants/five-essential-phone-screen-questions.html"><table border=1 width=100%><tr><td><table border=1 bgcolor=#ffffff cellpadding=10 cellspacing=0 width=100% color=#ffffff><tr><td><font face="" color=black size=-1>This is <b><font color=#0039b6>G</font> <font color=#c41200>o</font> <font color=#f3c518>o</font> <font color=#0039b6>g</font> <font color=#30a72f>l</font> <font color=#c41200>e</font></b>'s text-only <a href="http://www.google.com/intl/en/help/features.html#cached"><font color=blue>cache</font></a> of <A HREF="http://www.cabochon.com/~stevey/blog-rants/five-essential-phone-screen-questions.html"><font color=blue>http://www.cabochon.com/~stevey/blog-rants/five-essential-phone-screen-questions.html</font></a> as retrieved on 6 Sep 2006 01:45:09 GMT.<br>
<b><font color=#0039b6>G</font> <font color=#c41200>o</font> <font color=#f3c518>o</font> <font color=#0039b6>g</font> <font color=#30a72f>l</font> <font color=#c41200>e</font></b>'s cache is the snapshot that we took of the page as we crawled the web.<br>
The page may have changed since that time.  Click here for the <A HREF="http://www.cabochon.com/~stevey/blog-rants/five-essential-phone-screen-questions.html"><font color=blue>current page</font></a> without highlighting.<br>
Click here for the <A HREF="http://209.85.165.104/search?q=cache:-fS-5kHxxH0J:www.cabochon.com/~stevey/blog-rants/five-essential-phone-screen-questions.html+the+five+essential+phone+screen&hl=en&client=firefox-a&hs=FjH&strip=0"><font color=blue>full cached page</font></a> with images included.<br>To link to or bookmark this page, use the following url: <code>http://www.google.com/search?q=cache:-fS-5kHxxH0J:www.cabochon.com/~stevey/blog-rants/five-essential-phone-screen-questions.html+the+five+essential+phone+screen&amp;hl=en&amp;client=firefox-a&amp;hs=QOc&amp;strip=1</code></font><br><br><center><font size=-2><i>Google is neither affiliated with the authors of this page nor responsible for its content.</i></font></center></td></tr>
<tr><td>
<table border=0 cellpadding=0 cellspacing=0><tr><td><font face="" color=black size=-1>These search terms have been highlighted:&nbsp;</font></td><td bgcolor=#ffff66><b><font face="" color=black size=-1>five&nbsp;</font></b></td><td bgcolor=#a0ffff><b><font face="" color=black size=-1>essential&nbsp;</font></b></td><td bgcolor=#99ff99><b><font face="" color=black size=-1>phone&nbsp;</font></b></td><td bgcolor=#ff9999><b><font face="" color=black size=-1>screen&nbsp;</font></b></td></tr></table>
</td></tr></table></td></tr></table>
<hr>
<html>
<head>
<title> The Five Essential Phone Screen Questions </title>

</head>
<body>

<h2> The <b style="color:black;background-color:#ffff66">Five</b> <b style="color:black;background-color:#a0ffff">Essential</b> <b style="color:black;background-color:#99ff99">Phone</b> <b style="color:black;background-color:#ff9999">Screen</b> Questions </h2>

<p> I've been on a lot of SDE interview loops lately where the
candidate failed miserably: not-inclined votes all around, even from
the <b style="color:black;background-color:#99ff99">phone</b> screeners who brought the person in initially. <p>

<p> It's usually pretty obvious when the candidate should have been
eliminated during the <b style="color:black;background-color:#99ff99">phone</b> screens.  Well, it's obvious in
retrospect, anyway: during the interviews, we find some horrible flaw
in the candidate which, had anyone thought to ask about it during the
<b style="color:black;background-color:#99ff99">phone</b> <b style="color:black;background-color:#ff9999">screen</b>, would surely have disqualified the person. </p> 

<p> But we didn't ask.  So the candidate came in for interviews and wound
up wasting everyone's time. </p> 

<h3>Antipatterns</h3>

<p> I've done informal postmortems on at least a hundred <b style="color:black;background-color:#99ff99">phone</b> screens,
many of them my own.  Whenever a candidate bombs the interviews, I
want to know what went wrong with the <b style="color:black;background-color:#ff9999">screen</b>.  And guess what?  A
pattern has emerged.  Two patterns, actually. </p> 

<p> The first pattern is that for most failed <b style="color:black;background-color:#99ff99">phone</b> screens, 
<font color="B22222">the candidate did most of the talking.</font>
The screener only asked about stuff on the candidate's resume, and the
candidate was able to talk with passion and enthusiasm about this
incredibly cool thing they did, blah blah blah, and the screener was
duly impressed. </p> 

<p> That's how many/most <b style="color:black;background-color:#99ff99">phone</b> screens go wrong. </p> 

<p> The right way to do a <b style="color:black;background-color:#99ff99">phone</b> <b style="color:black;background-color:#ff9999">screen</b> is to do most of the talking, or at
least the driving.  You look for specific answers, and you guide the
conversation along until you've got the answer or you've decided the
candidate doesn't know it.  Whenever I forget this, and get lazy and
let the candidate drone on about their XML weasel-pin connector
project, I wind up bringing in a dud. </p> 

<p> The second pattern is that <font color="B22222">one-trick ponies only know
one trick.</font> Candidates who have programmed mostly
in a single language (e.g. C/C++), platform (e.g. AIX) or
framework (e.g. J2EE) usually have major, gaping holes in
their skills lineup.  These candidates will fail their interviews
here because our interviews cover a broad range of skill areas. </p> 

<p> These two <b style="color:black;background-color:#99ff99">phone</b> <b style="color:black;background-color:#ff9999">screen</b> (anti-)patterns are related: if you only ask
the candidate about what they know, you've got a fairly narrow view of
their abilities.  And you're setting yourself up for a postmortem on
your <b style="color:black;background-color:#99ff99">phone</b> <b style="color:black;background-color:#ff9999">screen</b>. </p> 

<h3>Acid Tests</h3>

<p> In an effort to make life simpler for <b style="color:black;background-color:#99ff99">phone</b> screeners, I've put
together this list of <b style="color:black;background-color:#ffff66">Five</b> <b style="color:black;background-color:#a0ffff">Essential</b> Questions that you need to ask
during an SDE <b style="color:black;background-color:#ff9999">screen</b>.  They won't guarantee that your candidate will
be great, but they will help eliminate a huge number of candidates who
are slipping through our process today. </p> 

<p> These <b style="color:black;background-color:#ffff66">five</b> areas are litmus tests -- very good ones.  I've chosen them
based on the following criteria: </p> 

<p> 1) They're universal - every programmer needs to know them,
regardless of experience, so you can use them in all SDE
<b style="color:black;background-color:#99ff99">phone</b> screens, from college hires through 30-year veterans. </p> 

<p> 2) They're quick - they're areas that you can probe very
quickly, without eating too much into your <b style="color:black;background-color:#99ff99">phone</b>-<b style="color:black;background-color:#ff9999">screen</b> time.  Each
area can be assessed with 1 to 5 minutes of "weeder questions", and
each area has almost unlimited weeder questions to choose from. </p> 

<p> 3) They're predictors - there are certain common "SDE
profiles" that are easy to spot because they tend to fail (and I mean
really fail) in one or more of these <b style="color:black;background-color:#ffff66">five</b> areas.  So the
areas are amazingly good at weeding out bad candidates. </p> 

<p> You have to probe all <b style="color:black;background-color:#ffff66">five</b> areas; you can't skip any of them.  Each
area is a proxy for a huge body of knowledge, and failing it very
likely means failing the interviews, even though the candidate did
fine in the other areas. </p> 

<p> Without further ado, here they are: The <b style="color:black;background-color:#ffff66">Five</b> <b style="color:black;background-color:#a0ffff">Essential</b> Questions for
the first <b style="color:black;background-color:#99ff99">phone</b>-<b style="color:black;background-color:#ff9999">screen</b> with an SDE candidate: </p> 

<p> 1) <b>Coding.</b>  The candidate has to write some simple code,
with correct syntax, in C, C++, or Java. <br>
2) <b>OO design.</b> The candidate has to define basic OO
concepts, and come up with classes to model a simple problem.<br>
3) <b>Scripting and regexes.</b>  The candidate has to describe
how to find the <b style="color:black;background-color:#99ff99">phone</b> numbers in 50,000 HTML pages. <br>
4) <b>Data structures.</b>  The candidate has to demonstrate
basic knowledge of the most common data structures.<br>
5) <b>Bits and bytes.</b>  The candidate has to answer
simple questions about bits, bytes, and binary numbers. </p> 

<p> <font color="red">
Please understand:</font> &nbsp; what I'm looking for
here is a total vacuum in one of these areas.
It's OK if they struggle a little and then figure it out.
It's OK if they need some minor hints or prompting.
I don't mind if they're rusty or slow.  What you're looking
for is candidates who are utterly clueless, or horribly
confused, about the area in question. </p> 

<p> For example, you may find a candidate who decides that
a Vehicle class should be a subclass of ParkingGarage,
since garages contain cars.  This is just busted, and it's
un-fixable in any reasonable amount of training time. </p> 

<p> Or a candidate might decide, when asked to search for
<b style="color:black;background-color:#99ff99">phone</b> numbers in a bunch of text files, to write a 2000-line
C++ program, at which point you discover they've never
heard of "grep", or at least never used it. </p> 

<p> When a candidate is totally incompetent in one of these
Big <b style="color:black;background-color:#ffff66">Five</b> areas, the chances are very high that they'll
bomb horribly when presented with our typical interview
questions.  Last week I interviewed an SDE-2 candidate
who made both of the mistakes above (a vehicle inheriting
from garage, and the 2000-line C++ grep implementation.)
He was by no means unusual, even for the past month.  We've
been bringing in many totally unqualified candidates. </p>

<p> The rest of this document describes each area in more detail,
and gives example questions, and solutions. </p> 

<p> <font color="firebrick"><b>Area Number One:  Coding</b></font> </p> 

<p> The candidate has to write some code.  Give them a coding
problem that requires writing a short, straightforward
function.  They can write it in whatever language they
like, as long as they don't just call a library function
that does it for them. </p> 

<p> It should be a trivial problem, one that even a slow candidate can
answer in 5 minutes or less. </p>

<p> (If the candidate seems insulted by the thought of having to get their
hands dirty with a trivial coding question, after all their years of
experience, patents, etc., tell them it's required procedure and ask
them to humor you.  If they refuse, tell them we only interview people
who can demonstrate coding skills over the <b style="color:black;background-color:#99ff99">phone</b>, thank them for their
time, and end the call.) </p>

<p> Give them a few minutes to write and hand-simulate the code.  Tell
them they need to make it syntactically correct and complete.  Make
them read the code to you over the <b style="color:black;background-color:#99ff99">phone</b>.  Copy down what they read
back.  Put it into your writeup.  If they're sloppy, or don't want to
give you exact details, give them one more chance to correct it, and
then go with Not Inclined. </p> 

<p> <font color=firebrick>(Note added 10/6/04)</font> -- another
good approach being used by many teams is to give the candidate
"homework".  E.g. you can give them an hour to solve some coding
problem (harder than the ones below) and email the solution to you.
Works like a charm.  Definitely preferable to reading code over the
<b style="color:black;background-color:#99ff99">phone</b>. </p> 

<p> Anyway, here are some examples.  I've given solutions in Java, mostly.
I've gone back and forth on accepting solutions in other languages
(e.g. Ruby, Perl, Python), and I've decided that candidates need to be
able to code their answers in C, C++ or Java.  It's wonderful if they
know other languages, and in fact those who do tend to do a
lot better overall.  But to be an Amazon SDE, you need to
prove you can do C++ or Java first. </p> 

<p> <b>Example 1: &nbsp;</b> <i>Write a function to reverse a string.</i> </p> 

<p> Example <font color=#8A2BE2>Java</font> code: </p> 

<p> <font size=+1 face="courier, lucida, fixed"><pre>
    public static String reverse ( String s ) {
        int length = s.length(), last = length - 1;
        char[] chars = s.toCharArray();
        for ( int i = 0; i &lt; length/2; i++ ) {
            char c = chars[i];
            chars[i] = chars[last - i];
            chars[last - i] = c;
        }
        return new String(chars);
    }
</pre></font> </p>

<p> Example output for "Madam, I'm Adam":  &nbsp; <font color="#555555">madA m'I ,madaM</font> </p> 

<p> <b>Example 2:&nbsp;</b> <i>Write function to compute Nth fibonacci number:</i> </p> 

<p> <font color=#8A2BE2>Java</font> and <font color="1874CD">C/C++:</font>
<font size=+1 face="courier, lucida, fixed"><pre>
    static long fib(int n) {
        return n &lt;= 1 ? n : fib(n-1) + fib(n-2);
    }
</pre></font></p>

<p><font color=#8A2BE2><i>(Java Test harness)</i></font>
<font size=+1 face="courier, lucida, fixed"><pre>
    public static void main ( String[] args ) {
        for ( int i = 0; i &lt; 10; i++ ) {
            System.out.print ( fib(i) + ", " );
        }
        System.out.println ( fib(10) );
    }
</pre></font> </p>

<p> <font color="#1874CD"><i>(C/C++ Test Harness)</i></font>
<font size=+1 face="courier, lucida, fixed"><pre>
    main () {
        for ( int i = 0; i &lt; 10; i++ ) {
            printf ( "%d, ", fib(i) );
        }
        printf ( "%d\n", fib(10) );
    }
</pre></font> </p>

<p> Test harness output: &nbsp; </p>

<p> <font color=#555555>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</font> </p> 

<p> <b>Example 3:&nbsp;</b> <i>Print out the grade-school multiplication table up to 12x12</i> </p> 

<p> <font color=#8A2BE2>Java:</font>  (similar for <font color=#1874CD>C/C++</font>)
<font size=+1 face="courier, lucida, fixed"><pre>
    public static void multTables ( int max )
    {
        for ( int i = 1; i &lt;= max; i++ ) {
            for ( int j = 1; j &lt;= max; j++ ) {
                System.out.print ( String.format ( "%4d", j * i ));
            }
            System.out.println();
        }
    }
</pre></font> </p>

<p> Example output: </p>

<font color=#555555><pre>
   1   2   3   4   5   6   7   8   9  10  11  12
   2   4   6   8  10  12  14  16  18  20  22  24
   3   6   9  12  15  18  21  24  27  30  33  36
   4   8  12  16  20  24  28  32  36  40  44  48
   5  10  15  20  25  30  35  40  45  50  55  60
   6  12  18  24  30  36  42  48  54  60  66  72
   7  14  21  28  35  42  49  56  63  70  77  84
   8  16  24  32  40  48  56  64  72  80  88  96
   9  18  27  36  45  54  63  72  81  90  99 108
  10  20  30  40  50  60  70  80  90 100 110 120
  11  22  33  44  55  66  77  88  99 110 121 132
  12  24  36  48  60  72  84  96 108 120 132 144
</pre></font>

<p> <b>Example 4:&nbsp;</b> <i>Write a function that sums up integers from
a text file, one int per line.</i> </p>

<p> <font color=#8A2BE2>Java:</font>
<font size=+1 face="courier, lucida, fixed"><pre>
    public static void sumFile ( String name ) {
        try {
            int total = 0;
            BufferedReader in = new BufferedReader ( new FileReader ( name ));
            for ( String s = in.readLine(); s != null; s = in.readLine() ) {
                total += Integer.parseInt ( s );
            }
            System.out.println ( total );
            in.close();
        }
        catch ( Exception xc ) {
            xc.printStackTrace();
        }
    }
</pre></font> </p>

<p> <b>Example 5:&nbsp;</b> <i>Write function to print the odd numbers from 1 to 99.</i> </p> 

<p> <font color="1874CD">C/C++:</font>
<font size=+1 face="courier, lucida, fixed"><pre>
    void printOdds() {
        for (int i = 1; i &lt; 100; i += 2) {
            printf ("%d\n", i); // or cout << i << endl;
        }
    }
</pre></font> </p>

<p> <font color=#8A2BE2>Java:</font> </p>

<p> <font size=+1 face="courier, lucida, fixed"><pre>
    public static void printOdds() {
        for (int i = 1; i &lt; 100; i += 2) {
            System.out.println ( i );
        }
    }
</pre></font> </p>

<p> <b>Example 6:&nbsp;</b> <i>Find the largest int value in an int array.</i> </p> 

<p> <font color=#8A2BE2>Java:</font>
<font size=+1 face="courier, lucida, fixed"><pre>
    public static int largest ( int[] input ) {
    int max = Integer.MIN_VALUE;
    for ( int i = 0; i &lt; input.length; i++ ) {
        if ( input[i] &gt; max ) max = input[i];
        }
        return max;
    }
</pre></font> </p>

<p> <b>Example 7:&nbsp;</b> <i>Format an RGB value (three 1-byte
numbers) as a 6-digit hexadecimal string.</i> </p>

<p> <font color=#8A2BE2>Java:</font>
<font size=+1 face="courier, lucida, fixed"><pre>
    public String formatRGB ( int r, int g, int b ) {
        return (toHex(r) + toHex(g) + toHex(b)).toUpperCase();
    }

    public String toHex ( int c ) {
        String s = Integer.toHexString ( c );
        return ( s.length() == 1 ) ? "0" + s : s;
    }
</pre></font> </p>

<p> Or in <font color=#8A2BE2>Java 1.5:</font>
<font size=+1 face="courier, lucida, fixed"><pre>
    public String formatRGB ( int r, int g, int b ) {
        return String.format ( "%02X%02X%02X", r, g, b );
    }
</pre></font> </p>

<p> Example output for (255, 0, 128): &nbsp; </p>

<p> You can ask any question you like; doesn't have to be one of
the ones above.  They're just examples. </p>

<p> Some properties of a good weeder <b style="color:black;background-color:#99ff99">phone</b>-<b style="color:black;background-color:#ff9999">screen</b> coding question are: </p>

<ol>
  <li> It's simple.  It has to be something that you
       should be able to solve, trivially, in about 2 minutes
       or less.  Not too tricky.  Basic stuff. <p>

  <li> You've solved it.  You shouldn't ask a question
       unless you've solved it yourself recently, so you know
       it's a reasonable question, and you can evaluate their
       answer to it.  You should consider coding it yourself
       during the time you've given them to do it. <p>

  <li> It has loops or recursion.  Recursion is actually
       preferable.  Being able to reason recursively or inductively
       is important for many areas of computing, including using
       heirarchical data representations (e.g. XML), distributed
       computing, searching, and sorting.  Many candidates simply
       can't think recursively, and this often goes undetected
       until interview-time.  Try to find out at compile-time!
       Er, <b style="color:black;background-color:#99ff99">phone</b>-<b style="color:black;background-color:#ff9999">screen</b> time, that is. <p>

  <li> It has formatted output.  This is a basic skill,
       useful for debugging, simple report generation, and lots
       of other things.  "printf" is a universal standard; it exists
       in C, C++, Java, Perl, Ruby, Python, and virtually every
       other mainstream language, at least as a library call.
       Like file I/O, it's a good indicator as to whether the
       candidate has written "real" code before. <p>

  <li> It has text-file I/O.  Candidates who have worked
       in frameworks for too long often become unable to function
       as programmers outside that framework.  Not being able to
       do simple file I/O is a common indicator that they've
       grown overly dependent on a particular framework. <p>
</ol>

<p>It's hard to cover all these things and still be
a short weeder question.  If you think of a question that
has all these properties, let me know. <p>

<p><font color="firebrick"><b>Area Number Two: Object-Oriented
Programming</b></font></p>

<p> We shouldn't hire SDEs (arguably excepting college hires)
who aren't at least somewhat proficient with OOP.  I'm not
claiming that OOP is good or bad; I'm just saying you have
to know it, just like you have to know the things you can
and can't do at an airport security checkpoint. </p> 

<p> Two reasons: </p> 

<p> 1) OO has been popular/mainstream for more than 20 years.
Virtually every programming language supports OOP in some way.
You can't work on a big code base without running into it. </p> 

<p> 2) OO concepts are an important building block for creating
good service interfaces.  They represent a shared understanding
and a common vocabulary that are sometimes useful when talking
about architecture. </p> 

<p> So you have to ask candidates some OO stuff on the <b style="color:black;background-color:#99ff99">phone</b>. </p> 

<p> <b>a)</b> <i>Terminology</i> </p> 

<p> The candidate should be able to give satisfactory definitions
for a random selection of the following terms: </p>

<p> <ol>
  <li> class, object (and the difference between the two)
  <li> instantiation
  <li> method (as opposed to, say, a C function)
  <li> virtual method, pure virtual method
  <li> class/static method
  <li> static/class initializer
  <li> constructor
  <li> destructor/finalizer
  <li> superclass or base class
  <li> subclass or derived class
  <li> inheritance
  <li> encapsulation
  <li> multiple inheritance (and give an example)
  <li> delegation/forwarding
  <li> composition/aggregation
  <li> abstract class
  <li> interface/protocol (and different from abstract class)
  <li> method overriding
  <li> method overloading (and difference from overriding)
  <li> polymorphism (without resorting to examples)
  <li> is-a versus has-a relationships (with examples)
  <li> method signatures (what's included in one)
  <li> method visibility (e.g. public/private/other)
</ol> </p>

<p>
These are just the bare basics of OO.  Candidates should
know this stuff cold.  It's not even a complete list; it's
just off the top of my head. </p>

<p> Again, I'm not advocating OOP, or saying anything about it,
other than that it's ubiquitious so you have to know it.
You can learn this stuff by reading a single book and
writing a little code, so no SDE candidate (except maybe
a brand-new college hire) can be excused for not knowing
this stuff. </p> 

<p> I draw a distinction between "knows it" and "is
smart enough to learn it."  Normally I allow people through
for interviews if they've got a gap in their knowledge,
as long as I think they're smart enough to make it up
on the job. </p> 

<p> But for these <b style="color:black;background-color:#ffff66">five</b> areas, I expect candidates to know them.
It's not just a matter of being smart enough to learn them.
There's a certain amount of common sense involved; I can't
imagine coming to interview at Amazon and not having brushed
up on OOP, for example.  But these areas are also so fundamental 
that they serve as real indicators of how the person will do on
the job here. </p> 

<p> <b>b)</b> <i>OO Design</i> </p> 

<p> This is where most candidates fail with OO.  They can
recite the textbook definitions, and then go on to produce
certifiably insane class designs for simple problems.  For
instance: </p>

<p> <ul>
  <li> They may have Person multiple-inherit from Head, Body, Arm, and Leg.
  <li> They may have Car and Motorcycle inherit from Garage.
  <li> They may produce an elaborate class tree for Animals,
       and then declare an enum ("Lion = 1, Bear = 2", etc.)
       to represent the type of each animal.
  <li> They may have exactly one static instance of every
       class in their system.
</ul> </p>

<p>(All these examples are from real candidates I've interviewed
in the past 3 weeks.) </p>

<p> Candidates who've only studied the terminology without ever
doing any OOP often don't really get it. When they go to
produce classes or code, they don't understand the
difference between a static member and an instance member,
and they'll use them interchangeably. </p>

<p> Or they won't understand when to use a subclass versus an
attribute or property, and they'll assert firmly that a
car with a bumper sticker is a subclass of car.  (Yep,
2 candidates have told me that in the last 2 weeks.) </p> 

<p> Some don't understand that objects are supposed to know
how to take care of themselves.  They'll create a bunch of
classes with nothing but data, getters, and setters (i.e.,
basically C structs), and some Manager classes that contain
all the logic (i.e., basically C functions), and voila,
they've implemented procedural programming perfectly using
classes. </p> 

<p> Or they won't understand the difference between a char*,
an object, and an enum.  Or they'll think polymorphism is
the same as inheritance.  Or they'll have any number of
other fuzzy, weird conceptual errors, and their designs
will be fuzzy and weird as well. </p> 

<p> For the OO-design weeder question, have them describe: </p>

<p> <ol>
  <li> What classes they would define.
  <li> What methods go in each class (including signatures).
  <li> What the class constructors are responsible for.
  <li> What data structures the class will have to maintain.
  <li> Whether any Design Patterns are applicable to this problem.
</ol> </p>

<p> Here are some examples: </p>

<p> <ol>
  <li> <p> Design a deck of cards that can be used for
       different card game applications. </p> 

       <p> <i><font color=#7B68EE>Likely classes:  a Deck,
       a Card, a Hand, a Board, and possibly Rank and Suit.
       Drill down on who's responsible for creating new
       Decks, where they get shuffled, how you deal cards, etc.
       Do you need a different instance for every card in a
       casino in Vegas?
       </font></i> </p> 

  <li> <p> Model the Animal kingdom as a class system, for
       use in a Virtual Zoo program. </p> 

       <p> <i><font color=#7B68EE>
       Possible sub-issues: do they know the animal kingdom at all?
       (I.e. common sense.)  What properties and methods do they
       immediately think are the most important?  Do they use
       abstract classes and/or interfaces to represent shared stuff?
       How do they handle the multiple-inheritance problem posed by,
       say, a tomato (fruit or veggie?), a sponge (animal or plant?),
       or a mule (donkey or horse?)
       </font></i> </p> 

  <li> <p> Create a class design to represent a filesystem. </p> 

       <p> <i><font color=#7B68EE>
       Do they even know what a filesystem is, and what services it
       provides?  Likely classes: Filesystem, Directory, File,
       Permission.  What's their relationship?  How do you
       differentiate between text and binary files, or do you need to?
       What about executable files?  How do they model a Directory
       containing many files?  Do they use a data structure for it?
       Which one, and what performance tradeoffs does it have?
       </font></i> </p> 

  <li> <p> Design an OO representation to model HTML. </p> 

       <p> <i><font color=#7B68EE>
       How do they represent tags and content?  What about containment
       relationships?  Bonus points if they know that this has already
       been done a bunch of times, e.g. with DOM.  But they still have
       to describe it.
       </font></i> </p> 
</ol> </p>

<p>The following commonly-asked OO design interview questions are
probably too involved to be good <b style="color:black;background-color:#99ff99">phone</b>-<b style="color:black;background-color:#ff9999">screen</b> weeders: </p>

<p> <ol>
  <li> Design a parking garage.
  <li> Design a bank of elevators in a skyscraper.
  <li> Model the monorail system at Disney World.
  <li> Design a restaurant-reservation system.
  <li> Design a hotel room-reservation system.
</ol> </p>

<p>A good OO design question can test coding, design, domain knowledge,
OO principles, and so on.  A good weeder question should probably
just target whether they know when to use subtypes, attributes, and
containment. </p>

<p> <font color="firebrick"><b>Area Number Three: Scripting and
Regular Expressions</b></font> </p>

<p> Many C/C++/Java candidates, even some with 10+ years of
experience, would happily spend a week writing a 2,500-line
program to do something you could do in 30 seconds with a
simple Unix command. </p> 

<p> I now pose the following question to ALL candidates, whether on
the <b style="color:black;background-color:#99ff99">phone</b> or in an interview, because it eliminates so many of them:
</p>

<p> <font color="7B68EE">Last year my team had to remove all the
<b style="color:black;background-color:#99ff99">phone</b> numbers from 50,000 Amazon web page templates, since many
of the numbers were no longer in service, and we also wanted to route
all customer contacts through a single page. </p> 

<p> Let's say you're on my team, and we have to identify the pages
having probable U.S. <b style="color:black;background-color:#99ff99">phone</b> numbers in them.  To simplify the problem
slightly, assume we have 50,000 HTML files in a Unix directory tree,
under a directory called "/website".  We have 2 days to get a list of
file paths to the editorial staff.  You need to give me a list of the
.html files in this directory tree that appear to contain <b style="color:black;background-color:#99ff99">phone</b>
numbers in the following two formats: (xxx) xxx-xxxx and
xxx-xxx-xxxx. </p>

<p>How would you solve this problem?  Keep in mind our team is on a 
short (2-day) timeline. </p>
</font>

<p> Here are some facts for you to ponder: </p>

<p> <ol>
  <li> <p> Our Contact Reduction team really did have exactly
       this problem in 2003.  This isn't a made-up example. </p> 

  <li> <p> Someone on our team produced the list within an hour,
       and the list supported more than just the 2 formats above. </p> 

  <li> <p> About 25% to 35% of all software development engineer candidates, 
       independent of experience level, <font color="red">cannot 
       solve this problem</font>, even given the entire interview
       hour and lots of hints. </p>
</ol> </p>

<p>I take as much time as necessary to explain the problem to 
candidates, to ensure that they understand it and can paraphrase 
the problem requirements correctly. </p>

<p> For the record, I'm not being tricky here.  Once candidates start
down the wrong path (i.e. writing a gigantic C++ program to open
every file and parse character by character, using a home-grown
state machine), I stop them, tell them this will take too long,
and ask if there are any other possibilities.  I ask if there are
any tools or utilities that might be of use.  I give them plenty
of hints, and ultimately I tell them the answer. </p> 

<p> Even after I tell them the answer, they often still don't get it. </p>

<p> Here's one of many possible solutions to the problem: </p> 

<p> <font color="7B68EE" size=+1><pre>  grep -l -R --perl-regexp "\b(\(\d{3}\)\s*|\d{3}-)\d{3}-\d{4}\b" * > output.txt</pre></font> </p>

<p> But I don't even expect candidates to get that far, really.  If
they say, after hearing the question, "Um... grep?" then they're
probably OK.  I can ask them for the approximate syntax for the
regular expression to use, and as long as they have a reasonable clue,
I'm fine with it.  Heck, if they can tell me where they'd
look to find the syntax, I'm fine with it. </p>

<p> They can also use <font color="7B68EE">find</font>, or write a
Perl script (or awk or bash or etc.).  Anything that shows they have
even the tiniest inkling of why Unix is Unix. </p>

<p> They can even write a Java or C++ program, provided they can actually
write an entire working program in, say, half an hour or less, on the
board, or at least convince me that they will get it working quickly.
But I've only ever had that happen once; an insanely good C++
programmer burned through a 175-line C++ program on the whiteboard
that more or less solved it.  We made him an offer.  But usually they
throw in the towel when they find out they have to remember how to do
file I/O, or traverse a directory tree. </p> 

<p> For what it's worth, this failure mode is unique to Java and
C/C++ programmers.  Perl programmers laugh and solve it in
30 seconds or less.  I have some easy questions that make
Perl programmers cry, but this isn't one of them. </p> 

<p> In my experience, a programmer who only knows one language
(where C and C++ count as one language for this exercise)
is usually completely lost in one of these <b style="color:black;background-color:#ffff66">Five</b> <b style="color:black;background-color:#a0ffff">Essential</b> Areas. </p> 

<p> You don't necessarily have to ask the HTML <b style="color:black;background-color:#99ff99">phone</b>-number question.
Another one I used to ask, one that worked equally well, was: </p> 

<p> <font color="7B68EE">Let's say you're on my team, and
I've decided I'm a real stickler for code formatting.
But I've got peculiar tastes, and one day I decide I want
to have all parentheses stand out very clearly in your code. </p> 

<p> So let's say you've got a set of source files in C, C++, or
Java.  Your choice.  And I want you to modify them so that
in each source file, every open- and close-paren has exactly
one space character before and after it.  If there is any
other whitespace around the paren, it's collapsed into a 
single space character. </p>

<p> For instance, this code: <p> </p>

<p> <font face="courier, lucida, fixed">
  foo (bar (   new Point(x, graph.getY())   ));
</font> </p>

<p> Would be modified to look like this: </p> 

<p> <font face="courier, lucida, fixed">
  foo ( bar ( new Point ( x, graph.getY ( ) ) ) ) ;
</font> </p>

<p> I tell you (as your manager) that I don't care how you
solve this problem.  You can take the code down to Kinko's
Copies and manually cut and paste the characters with
scissors if you like. </p> 

<p> How will you solve this problem?</font> </p>

<p> Same thing, more or less.  You'd do it with a Unix command like sed
(using a regular expression), or do it in your editor using a regex,
or write a quick Ruby script, whatever.  I'd even accept having them
use a source-code formatter, provided they can tell me in
detail how to use it, during the interview (to a level of detail that
convinces me they've used it before.) </p> 

<p> There are all sorts of variations on this problem.  Generally
you want to come up with a real-life scenario that involves 
searching text files for patterns, and see if the candidate
wants to solve it by writing a giant chunk of C++ or Java
code. </p> 

<p><font color="firebrick"><b>Area Number Four:  Data Structures</b></font>
</p>

<p> SDE candidates need to demonstrate a basic understanding of the
most common data structures, and of the fundamentals of "big-O"
algorithmic complexity analysis. </p> 

<p> Here's what they need to know about big-O.  They need to know
that algorithms usually fall into the following performance
classes:  constant-time, logarithmic, linear, polynomial,
exponential, and factorial. </p> 

<p> For the standard data structures in java.util, STL, or those built
into a higher-level language, they need to know the big-O complexity
for the operations on those data structures.  Example:  they
should know that finding an element in a hashtable is usually
constant-time, that finding an element in a balanced binary
tree is order log(n), that finding an element in a linked list is
order N, and that finding an element in a sorted array is order log(n).
Similarly for insert/update/delete operations. </p>  

<p> And they should be able to explain why each operation falls into a
particular complexity class.  For instance: "Computing a hash value
doesn't depend on the number of items in the hashtable."  Or: "you
have to search the entire linked list, even if it's sorted, to find an
arbitrary element in it."  No math needed, no proofs, just explanations. </p> 

<p> The (concrete) data structures they absolutely must understand
are these: </p> 

<p> 1) <font color="7B68EE">arrays</font> - I'm talking about
C-language and Java-language arrays:  fixed-sized, indexed, contiguous
structures whose elements are all of the same type, and whose elements
can be accessed in constant time given their indices. </p> 

<p> 2) <font color="7B68EE">vectors</font> - also known as "growable 
arrays" or ArrayLists.  Need to know that they're objects that
are backed by a fixed-size array, and that they resize
themselves as necessary. </p> 

<p> 3) <font color="7B68EE">linked lists</font> - lists made of nodes that contain
a data item and a pointer/reference to the next (and possibly
previous) node. </p> 

<p> 4) <font color="7B68EE">hashtables</font> - amortized constant-time access
data structures that map keys to values, and are backed
by a real array in memory, with some form of collision
handling for values that hash to the same location. </p> 

<p> 5) <font color="7B68EE">trees</font> - data structures that consist of nodes
with optional data elements and one or more child
pointers/references, and possibly parent pointers,
representing a heirarchical or ordered set of data elements. </p> 

<p> 6) <font color="7B68EE">graphs</font> - data structures that represent
arbitrary relationships between members of any data set,
represented as networks of nodes and edges. </p> 

<p> There are, to be sure, many other important data structures one
should know about, but not knowing about the six listed above is
inexcusable, and grounds for rejection in a <b style="color:black;background-color:#99ff99">phone</b> <b style="color:black;background-color:#ff9999">screen</b>. </p>

<p> Candidates should be able to describe, for any of the data
structures above: </p> 

<p> <ul>
  <li> what you use them for (real-life examples) 
  <li> why you prefer them for those examples 
  <li> the operations they typically provide (e.g. insert, delete, find) 
  <li> the big-O performance of those operations (e.g. logarithmic, exponential) 
  <li> how you traverse them to visit all their elements, and what order they're visited in 
  <li> at least one typical implementation for the data structure
</ul> </p>

<p>Candidates should know the difference between an abstract data type
such as a Stack, Map, List or Set, and a concrete data structure such as
a singly-linked list or a hash table.  For a given abstract data type
(e.g. a Queue), they should be able to suggest at least two possible
concrete implementations, and explain the performance trade-offs between
the two implementations. </p>

<p> Example weeder questions: </p> 

<p> 1) <font color="7B68EE">What are some really common data
structures, e.g. in java.util?</font>
 </p>

<p> 2) <font color="7B68EE">When would you use a linked list vs. a
vector?</font> </p>

<p> 3) <font color="7B68EE">Can you implement a Map with a tree?
What about with a list?  </font> </p>

<p> 4) <font color="7B68EE">How do you print out the nodes of a
tree in level-order (i.e. first level, then 2nd level, then 3rd level,
etc.)</font> </p>

<p> 5) <font color="7B68EE">What's the worst-case insertion
performance of a hashtable?  Of a binary tree?</font> </p>

<p> 6) <font color="7B68EE">What are some options for implementing
a priority queue?</font> </p>

<p> And so on.  Just a few quick questions should cover this
area, provided you don't focus exclusively on linear ordered
sequences (lists, arrays, vectors and the like). </p> 

<p>
<font color="firebrick"><b>Area Number <b style="color:black;background-color:#ffff66">Five</b>:  Bits and Bytes</b></font>
</p>

<p> This area is fairly contentious, at least inasmuch as people
who don't know this area claim you don't need to know it. </p> 

<p> (Hint:  that's true for everything.  Nobody likes to
admit they don't know something you need to know.  I'll start:
I should know more about math; it's inexcusable.  I'm doing
all kinds of stuff the long, slow, dumb way because of my rusty
math skills.  But at least I admit it, and I've been studying
my math books semi-regularly in an attempt to repair my skills.) </p> 

<p> Candidates do need to know about bits and bytes, at least at
the level that I'm outlining here.  Otherwise they're prone to having
an integer-overflow error in their code that brings the website down
and costs us millions.  Or spending a week trying to decode a
serialized object they're debugging.  Or whatever.  Computers don't
have ten fingers; they have one.  So people need to know this stuff. </p> 

<p> Candidates should know what bits and bytes are.  They should
be able to count in binary; e.g. they should be able to tell
you what 2^5 or 2^10 is, in decimal.  They shouldn't stare
blankly at you when you ask with 2^16 is.  It's a special number.
They should know it. </p> 

<p> They should know at least the logical operations AND, OR,
NOT, and XOR, and how to express them in their favorite/strongest
programming language. </p> 

<p> They should understand the difference between a bitwise-AND
and a logical-AND; similarly for the other operations. </p> 

<p> Candidates should know the probable sizes of the primitive
data types for a standard 32-bit (e.g. Intel) architecture. </p> 

<p> If they're a Java programmer, they should know exactly what
the primitive types are (byte, short, int, long, float, double,
char, boolean) and, except for boolean, exactly how much space
is allocated for them per the Java Language specification. </p> 

<p> Everyone should know the difference between signed and unsigned
types, what it does to the range of representable values
for that type, and whether their language supports signed
vs. unsigned types. </p> 

<p> Candidates should know the bitwise and logical operators
for their language, and should be able to use them for
simple things like setting or testing a specific bit, or
set of bits. </p> 

<p> Candidates should know about the bit-shift operators in their
language, and should know why you would want to use them. </p> 

<p> A good weeder question for this area is: </p> 

<p> <font color="7B68EE">Tell me how to test whether the high-order
bit is set in a byte.</font> </p> 

<p> Another, more involved one is: </p> 

<p> <font color="7B68EE">Write a function to count all the bits in an int value;
e.g. the function with the signature
<i><font face="courier, fixed">int countBits(int x)</font></i>
</font> </p> 

<p> Another good one is: </p> 

<p> <font color="7B68EE">Describe a function that takes an int value,
and returns true if the bit pattern of that int value is the
same if you reverse it (i.e. it's a palindrome); i.e.
<i><font face="courier, fixed">boolean isPalindrome(int x)</font></i></font> </p> 

<p> They don't have to code the last two, just convince you they'd 
take the right approach.  Although if you have them code it
correctly, it can count for your Coding weeder question too. </p> 

<p> C/C++ programmers should know about the sizeof operator
and how (and why/when) to use it.  Actually, come to think of it,
everyone should know this. </p> 

<p> All programmers should be able to count in hexadecimal, and
should be able to convert between the binary, octal, and hex
representations of a number. </p> 

<p><font color="firebrick"><b>Special Fast-Track Version</b></font></p>

<p> That's it for the <b style="color:black;background-color:#ffff66">Five</b> <b style="color:black;background-color:#a0ffff">Essential</b> <b style="color:black;background-color:#99ff99">Phone</b> <b style="color:black;background-color:#ff9999">Screen</b> Questions.  Hope
ya liked it. </p> 

<p> As a special reward for reading this far, here's a special
Bonus Feature:  a set of all-too-common answers that are 
almost always indicators of certain failure during our
interviews.  Even if I'm not on the loop! </p> 

<p> <b>Bad Sign #1:</b> </p> 

<p> <font face="courier, fixed">
Me: &nbsp; So!  What languages have you used, starting with your strongest? <br>
Them: (briskly) C, C++. <br>
Me: &nbsp;  (long, pregnant pause)<br>
Them:  (waiting patiently for me to continue)<br>
Me: &nbsp;  Any others?<br>
Them: Nope.  C, C++.
</font> </p> 

<p> <font color="7B68EE">Translation:</font> (in thick Southern drawl) &nbsp;
"We got both kinds of music here: country and western." </p> 

<p> <font color="7B68EE">Probable failure modes for this candidate:</font> </p>

<p> &nbsp; Will fail the HTML-<b style="color:black;background-color:#99ff99">phone</b>-number question and the OO design
question (but will get the OO terminology definitions mostly right.) </p> 

<p> <b>Bad Sign #1a:</b> </p> 

<p> <font face="courier, fixed">
Me: &nbsp; So!  What languages are you most familiar/proficient with? <br>
Them: (worried) I've done mostly Java lately.<br>
Me: &nbsp;  (long, pregnant pause)<br>
Them:  Yeah, um, Java. <br>
Me: &nbsp;  Any others?<br>
Them: Um, I did C in school a long time ago, but... pretty much
mostly Java now.
</font> </p> 

<p> <font color="7B68EE">Translation:</font> &nbsp;
"Country and Western were both too hardcore for me.  I got beat up in a bar." </p> 

<p> <font color="7B68EE">Probable failure modes for this candidate:</font>
&nbsp; Will fail the bits and bytes questions, the HTML-<b style="color:black;background-color:#99ff99">phone</b>-number
question, and most of the data structures questions. </p> 

<p> <b>Bad Sign #2:</b> </p> 

<p> <font face="courier, fixed">
Me: &nbsp; So!  What data structures do we have available to us,
as programmers? <br>
Them: Arrays, queues, vectors, stacks, lists, um, linked lists...<br>
Me: &nbsp;  OK, any others?<br>
Them: Um, doubly-linked lists, and, uh, array lists.<br>
Me: &nbsp;  Have you ever used a tree? <br>
Them: Oh! (laughs)  Yeah, um, I forgot about those.
</font> </p>

<p> <font color="7B68EE">Translation:</font>&nbsp;
"My family tree doesn't branch." </p> 

<p> <font color="7B68EE">Probable failure modes for this candidate:</font>
&nbsp; Very likely to fail data structures questions.  Will fail any
recursive problem, even a simple one like printing the elements of a linked
list recursively.  Will fail the HTML-<b style="color:black;background-color:#99ff99">phone</b>-number question, since
they obviously haven't ever used Perl if "hash" didn't leap to mind. </p> 

<p> <b>Bad Sign #3:</b> </p> 

<p> <font face="courier, fixed">
Me: &nbsp; So!  What the the primitive types in Java (or C++)?<br>
Them: Ummmm, there's, um, int.  And, uh, double. <br>
Me: &nbsp;  Any others?<br>
Them: Shoot, I'm drawing a blank right now.  Um, String? </p>
</font>

<p> <font color="7B68EE">Translation:</font>&nbsp;
"C made my head hurt.  &nbsp;Java is like sweet, sweet aspirin." </p> 

<p> <font color="7B68EE">Probable failure modes for this candidate:</font>
&nbsp; Will fail bits and bytes questions, and probably just about
everything else as well. </p> 

<p> <b>Bad Sign #4:</b> </p> 

<p> <font face="courier, fixed">
Me: &nbsp; So!  What text-editor do you use?<br>
Them: Visual Studio. <br>
Me: &nbsp; OK.  What about on Unix?<br>
Them: On Unix I use vi. <br>
Me: &nbsp; Er, yeah, vi is cool... ever used VIM?<br>
Them: No, just vi.  Always worked just fine for me.
</font> </p> 

<p> <font color="7B68EE">Translation:</font>&nbsp;
"Sometimes I type with my elbows when my hands are tired.  It's just as fast." </p> 

<p> <font color="7B68EE">Probable failure modes for this candidate:</font>
Will likely fail the HTML-<b style="color:black;background-color:#99ff99">phone</b>-number question.  Might pass the
interviews, but will need to be scheduled in geologic eras. </p> 

<p> <b>Bad Sign #5:</b> </p> 

<p> <font face="courier, fixed">
Me: &nbsp; So!  What did you study in your Operating Systems class?<br>
Them: Oh, that was a long time ago. I can hardly remember. Hehe. <br>
Me: &nbsp; How long ago was it?<br>
Them: 2 years. <br>
</font> </p> 

<p> <font color="7B68EE">Translation:</font>&nbsp;
"I want to use my MBA skills in a dynamic management role.  When's lunch?" </p> 

<p> <font color="7B68EE">Probable failure modes for this candidate:</font>
&nbsp; Will probably fail the coding question.  Probably any OS questions, too. </p>

<p> All my Insta-Bad Signs above are cliches, in that I've heard these
answers from at least 10 to 15 candidates (per question!), none of
whom ever got an offer from us.  I tend to ask questions like these as
a matter of course now. </p> 

<p><font color="firebrick"><b>Summary</b></font> </p>

<p> This stuff is the ABC's for programmers.  Actually it's
only going up through maybe J or K; it's not even halfway
through the alphabet.  But most programmers out there in the
Big Wide World will fail utterly in at least one of these areas. </p>

<p> Please cover all <b style="color:black;background-color:#ffff66">five</b> areas if you're a <b style="color:black;background-color:#99ff99">phone</b> screener.  If you're
the second screener, ask if you don't see evidence of them
in the first screener's notes.  (And then follow up and
remind the first screener they should have asked these things.) </p> 

<p> <div class="published">(Published Sep 28th 2004) </div> </p>

<p> <hr>
<div class="comment">Comments</div>
<hr> </p>

<p> You can put a spin on your 'reverse a string' coding question - first
have them write a func that prints out a C string without looping
constructs or using local vars. Then if they get that, ask them to
implement a reverse string function in the same manner as the first
one. Don't say "use recursion" - let them figure out its
straightforward applicability to the problem. That's, IMHO, how you
can gauge if they 'think recursively' when lightly nudged in that
direction: </p> 

<p> <pre>void print(char *s) {
  if (*s != 0) {
    putchar(*s);
    print(s+1);
  }
}

void printreverse(char *s) {
  if (*s != 0)
    printreverse(s+1);
    putchar(*s);
  }
}

int main() {
  char *s = "Hello world";
  print(s);
  putchar('\n');
  printreverse(s);
  putchar('\n');
}</pre> </p>

<p> Posted by: Martin N. at September 29, 2004 07:39 AM<p> </p>

<p><hr><p>

<p> Nice post Steve - thanks for the checklist. </p>

<p> Would you really accept this answer to the 'Write function to compute
Nth fibonacci number' question? </p>

<p> <pre>static long fib(int n) {
  return n &lt;= 1 ? n : fib(n-1) + fib(n-2);
}</pre> </p>

<p> I'd hope that most candidates would know that (without memoization of
results) the naive recursive solution is O(n!) in time. If they made
that error in production code it would be and utter disaster (probably
large enough to be noticed early by QA, but still...). </p>

<p> If the candidate didn't at least mention this caveat about their
solution, I'd prompt them to compare & contrast with alternatives. If
they didn't immediately give the iterative solution and explain the
big-O difference, that would be a red flag for me. </p>

<p> regards, </p>

<p> Chris </p>

<p> Posted by: Chris N. at September 29, 2004 08:36 PM<p> </p>
<p><hr><p>

<p> Er, a small error in my comment: </p>

<p> &gt;&gt;&gt;I'd hope that most candidates would know that (without
memoization of results) the naive recursive solution is O(n!) in
time. </p>

<p> I meant "is O(2^n) in time" of course. </p>

<p> Chris (blushing) </p>

<p> Posted by: Chris N. at September 29, 2004 08:39 PM<p> </p>

<p><hr><p>

<p> Yeah, that factorial fibo solution sucks. I'd be very happy if the
candidate told me that they could do it tail-recursively with an
accumulator parameter, even if I'm not sure you can do a
doubly-recursive call tail-recursively. I'd <i>still</i> be happy. </p>

<p> I was thinking of splitting out recursion from basic coding, but that
would be Six <b style="color:black;background-color:#a0ffff">Essential</b> Areas, and I only have <b style="color:black;background-color:#ffff66">five</b> fingers. </p>

<p> Posted by: Steve Yegge at September 30, 2004 03:42 AM<p> </p>

<hr>

<p> Interesting post overall...a couple of comments/issues I've seen when
doing <b style="color:black;background-color:#99ff99">phone</b> screens: </p>

<p> 1. How do you have a candidate read code to you over the <b style="color:black;background-color:#99ff99">phone</b> when
the candidate isn't a native English speaker and the <b style="color:black;background-color:#99ff99">phone</b> connection
is sub-optimal [I've had this more times than I can remember...] </p>

<p> 2. I have some issues with the "scripting" category--it expresses a
preference for hacky programmers who prefer speed over
maintainability. On our team (Customer Behavior) we're still cleaning
up a fair amount of such code that broke the moment a database machine
got moved between data centers. Yes, the code was written quickly, but
now our managers are wondering why we can't get to a stable production
system so quickly. The section also prefers UNIX programmers over,
say, people who worked with Windows for an entire career. </p>

<p> Posted by: Dan at October 7, 2004 01:44 AM<p> </p>

<hr>

<p> &gt; 1. How do you have a candidate read code to you over the <b style="color:black;background-color:#99ff99">phone</b><br>
&gt; when the candidate isn't a native English speaker and the <b style="color:black;background-color:#99ff99">phone</b><br>
&gt; connection is sub-optimal [I've had this more times than I can<br>
&gt; remember...] </p>

<p> Me too. </p>

<p> The best approach I've seen is to give the candidate a "homework"
question. Give them an hour to code up a solution to some problem
and email it to you. Several teams are doing this regularly, with
good results. </p>

<p> &gt; 2. I have some issues with the "scripting" category--it<br>
&gt; expresses a preference for hacky programmers who prefer speed<br>
&gt; over maintainability. </p>

<p> I'm sorry if I gave that impression. We don't want those kinds of
programmers here, obviously. The <b style="color:black;background-color:#ffff66">five</b> question areas here are a
delicate balance. This category is geared towards determining whether
someone has the self-sufficiency to be able to respond quickly to
emergencies affecting our customers. They still need to have good
judgement and good design skills. </p>

<p> I never actually specify that they need to write it as a script. I
just give them problems that are best handled that way: emergency
queries and backfills, for example.  I've had a few folks burn through
200-line Java or C++ apps that solved the problem, right there on the
board, and they got offers. </p>

<p> But after 4 1/2 years over in Customer Service, I've found that knowing
how to use "grep" and its ilk is a pretty important survival skill. </p>

<p> And we -are- Unix shop, after all. Unix isn't exactly a niche
operating system. There are people who've figured out the basics on
their own, even if their professional experience has all been with
Microsoft technologies. </p>

<p> But feel free to ask whatever works for you! </p>

<p> Posted by: Steve Yegge at October 7, 2004 02:27 AM<p> </p>

<hr>

<p> The ultra-cool solution to Fib is the closed-form constant time
solution. You need floating point and exponentiation, but that's
constant time on modern hardware. </p>

<p> There's also an off-by-one error of sorts in your printOdds()
functions. i should start at 1, not 0, or the function should be
renamed printEvens(). </p> 

<p> Posted by:  Darren V. at October 7, 2004 02:42 AM </p> 

<hr>

<p> Thanks Darren. Obviously extra-cool solutions are bonus points for the
candidate. </p>

<p> Fixed the loop typo. It was caused, interestingly, when I corrected my
original working code, after someone emailed me and complained about
the performance. Originally it did this: </p>

<p> <pre>for (int i = 0; i < 100; i++) {
  if (i % 2 != 0) System.out.println(i);
}</pre> </p>

<p> The point was to see if the candidate could write something that
worked at all, and I was whipping up examples at 3:00am. Had no idea
it would get so much attention. </p>

<p> In any case, someone objected to the fact that it wasn't simply
incrementing the loop counter by 2, so it performed poorly. So I went
and "optimized" it (an optimization that would go undetected by humans
or profilers in this case, as it's totally I/O bound), and in my
haste, broke it. </p>

<p> I suppose I should claim that I rigged the whole thing as a
demonstration of why optimizing stuff that doesn't matter is
needlessly risky. Or that I broke it so I could rant about why unit
testing is critical, even for your personal blog content. </p>

<p> But really I just made a bad fix. :) </p>

<p> Thanks again. </p>
<p> Posted by: Steve Yegge at October 7, 2004 03:11 AM<p> </p>

<hr>

<p> Thanks for posting this. I have been trying to improve my interviewing
skills, and this looks like a good set of basics for <b style="color:black;background-color:#99ff99">phone</b> screens. </p>

<p> Posted by: Timothy K. at October 11, 2004 11:20 PM<p> </p>

<hr>

<p> Just an FYI... </p>

<p> I tried using the find-the-<b style="color:black;background-color:#99ff99">phone</b>-numbers question on a candidate
yesterday, and she went straight for Java. I was getting ready to slap
her down when I noticed that Java 1.4 contains a regular expression
engine. With that enhancement, the write-a-complete-program solution
becomes more reasonable. </p>

<p>Posted by: Christopher B. at November 17, 2004 09:37 AM</p>

<hr>

<p> Yep. Most languages these days have (mostly) Perl5 compatible regexp
engines. Java's file handling is a bit more cumbersome than it'd be in
a scripting language, but not overly so. The problem is more about
understanding fundamental pattern-matching tools than it is about
scripting or any particular language. </p>

<p> Posted by: Steve Yegge at November 29, 2004 06:52 PM<p> </p>

<hr>

<p> I'm about to do my first <b style="color:black;background-color:#99ff99">phone</b> screening and this was very helpful. </p>

<p> Maybe I just don't want to admit that I don't have vital information,
but I don't know what 2^16 is. Jeff Bezos' <b style="color:black;background-color:#99ff99">phone</b> number? I don't
understand the significance of knowing powers of two off the top of
one's head. </p>

<p> Posted by: Jason R. at March 22, 2005 10:58 PM<p> </p>

<hr>

<p> Jason: there are many domains for which knowing binary counting is
useful, if not <b style="color:black;background-color:#a0ffff">essential</b>. </p>

<p> One is when you're doing stuff that involves a lot of bit- and
byte-manipulation; examples include network protocols, writing binary
serialization/marshalling code, and reading or reverse-engineering
file formats. </p>

<p> Another is when you're doing any sort of memory or pointer coding (or
more to the point, debugging) with C/C++ code. It's a lot easier to
stare at hex-dumps if you're good at translating between decimal and
hexadecimal (and binary). </p>

<p> Another broad class of problems involves data whose byte
representation is especially significant. UTF-8 and Unicode are good
examples. If you ever need to do internationalization, it can be a big
help to have a crystal-clear understanding of the meaning of each bit
in a byte, short, or int/word value. Actually, this may just be
another sub-example of the first domain I mentioned, but you get the
idea. </p>

<p> Lastly (and most importantly; all the other examples I've listed pale
to insignificance in comparison to this one), it's important for
algorithm time and space estimation. If you're trying to decide what
data structure to use for a given data set, and you know off the top
of your head that 2^16 is about 65,000, 2^20 is a million, 2^32 is 4
billion, and 2^64 is "big enough", then you'll have an easier time
with the decision. Looking at it backwards -- if you use a balanced
binary tree (or a log-n search algorithm), you can quickly estimate
the base-2 logarithm of your data-set size, which gives you the rough
number of steps involved in a lookup operation. </p>

<p> If you <i>don't</i> have a good feel for the growth rate of powers of
2, then a little old man will save your daughter, and you'll grant him
anything you want in your kingdom, and he'll say he just wants one
grain of rice on the first square of a chessboard, then 2 in the
second, 4 on the third, and so on. And then: you'll be all out of
rice. </p>

<p> Fortunately, you can memorize this stuff in less time than it took you
to post your comment. :) </p>

<p> Posted by: Steve Yegge at March 23, 2005 04:11 AM<p> </p>

<hr>

<p> This is an *excellent* resource, Steve. </p>

<p> I've noticed that a lot of the Java-steeped interviewees will use
Strings in their string reverse solutions like so: </p> 

<p> <pre>    for (int i = s.length - 1; i >= 0; i--) {
        returnS += s.substring(i, 1);
    }</pre> </p>

<p> Most will understand that objects are being allocated and discarded
per loop, and will use a StringBuffer to make things "more
efficient". Interestingly, a couple of folks couldn't explain _why_ it
would be more efficient. </p>

<p> It's helpful to ask how they would design a limited StringBuffer class
using just primitive types to try to help dispel library addiction. It
can be surprisingly intimidating for some folks, especially when it
comes to reallocating arrays. (Ironic, considering the allocation-fest
of their original solutions...) </p>

<p> Thus, I recommend it as another coding question -- though just to talk
through, not to code over the <b style="color:black;background-color:#99ff99">phone</b>. Alternatively, asking for the
reverse() function using just primitives would do the same thing, but
without the scariness of dreaded reallocation. </p>  

<p> Posted by: Jeremy D. at March 29, 2005 12:54 AM <p> </p>

<p>
<hr>
<p />
<a href="index.html">Back to Stevey's Drunken Blog Rants(tm)</a>
<p />
image of my email address, steve dot yegge at ye olde gmail

</body>
</html>
